# from pudb import set_trace; set_trace()
from typing import List
import math
from functools import lru_cache
from collections import defaultdict, Counter
from bisect import bisect_left


class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        """First find the total number of partitions. This shall be:

        NC1 + NC2 + NC3 + ... + NC(N-1)

        Use binomial theorem, the above can be computed as tot = (1 + 1)^N - 2

        Then we sort num and find all the impossible cases. Note that impossible
        cases can only happend in the first j values such that nums[j + 1] >= k

        We can use binary search to find such j.

        To find the number of impossible cases, we use DP, where DP[i][y] is the
        number of combinations whose sum is smaller or equal to y. Since i and
        y are at most 1000, this DP is not too expensive.

        Finally, the result is tot - impossible * 2. We need to double the
        impossible because each impossible combination can appear either in the
        first or second partition.

        O(NlogN + logN + NK)

        UPDATE: note that tot - impossible * 2 might be negative, which means
        there are too many impossible cases. In that case, there is no valid
        partition

        UPDATE: the process of finding the number of impossible sequences can
        be achieved by a 1D DP. We say dp[i] is the total number of impossible
        sequences in nums[i:j] with a sum smaller than k. For dp[i - 1], if it
        is smaller than the current limit, the number of impossible cases
        including nums[i - 1] is 1 + dp[limit - nums[i - 1]]. We then add this
        on top of the original dp[limit]; it gives us the total number of
        impossible cases from nums[i - 1:j]

        205 ms, faster than 73.39%

        UPDATE: use knapsack idea to do the DP part.
        """
        nums.sort()
        N = len(nums)
        MOD = 10**9 + 7

        j = bisect_left(nums, k)  # nums[j] >= k
        tot = (1 << N) - 2
        if j == 0:
            return tot % MOD

        # need to find in nums[:j] all subsequence that adds up smaller than k
        # These are the impossible cases.
        dp = [0] * k
        for i in range(j - 1, 0, -1):
            for lim in range(k - 1, nums[i] - 1, -1):
                dp[lim] = 1 + dp[lim - nums[i]] + dp[lim]  # take nums[i] or not take nums[i]
        impossible = 1 + dp[k - 1 - nums[0]] + dp[k - 1]
        return max(0, tot - impossible * 2) % MOD


sol = Solution()
tests = [
    ([1,2,3,4], 4, 6),
    ([3,3,3], 4, 0),
    ([6,6], 2, 2),
    ([10,11,12,13], 10, 14),
    ([73,16,86,25,98,92,15,11,87,88,88,94,83,74,1,48,91,9,45], 61, 524152),
    ([1, 9, 11, 15, 16, 25, 45, 48], 61, 120),
    ([1, 9, 11, 45, 48], 61, 0),
    ([96,40,22,98,9,97,45,22,79,57,95,62], 505, 0),
    ([280,924,243,168,405,964,928,684,643,615,150,54,417,611,419,915,692,474,401,711,38,623,548,214,781,838,506,234,862,810,721,865,637,752,471,80,285,228,468,148,903,26,832,738,224,474,937,352,152,240,519,797,996,1000,474,731,582,170,244,902,554,424,974,585,401,368,34,412,779,836,70,352,11,999,52,792,393,24,756,119,820,550,190,253,700,797,408,547,954,670,805,539,539,250,371,994,314,412,489,305,115,639,717,45,758,977,88,942,390,575,30,971,546,597,979,701,530,400,784,446,148,604,265,230,728,703,448,526,23,42,773,402,512,742,852,161,260,943,362,243,147,133,20,822,752,566,415,185,511,731,120,968,605,105,941,220,537,259,920,105,620,847,320,414,927,731,890,898,130,941,280,960,427,307,183,482,771,872,913,422,884,933,409,860,871,524,558,668,628,939,801,420,320,737,768,445,806,957,667,176,745,549,680,890,347,696,277,374,878,4,983,44,536,53,447,260,954,643,20,123,80,808,610,507,544,429,501,61,118,991,549,990,56,501,924,419,19,835,869,930,40,311,549,20,931,668,95,355,830,957,747,73,12,658,757,368,329,400,805,473,805,71,578,484,712,72,499,749,22,166,859,44,287,220,301,91,754,305,206,716,229,144,277,971,967,866,96,540,808,678,347,203,597,119,717,641,14,712,860,977,951,746,317,589,91,754,836,234,860,896,323,913,56,810,778,312,423,623,438,224,791,126,637,909,765,646,447,500,418,572,899,228,89,510,706,487,405,158,339,354,445,47,915,895,402,447,280,255,184,739,163,136,55,225,646,559,161,838,802,588,205,888,603,134,535,48,396,694,65,874,99,929,311,738,42,843,375,35,755,156,494,990,257,548,678,628,794,523,888,763,144,252,937,883,265,134,414,197,131,691,53,350,772,692,831,581,864,759,779,147,112,918,679,503,996,41,26,617,377,82,594,36,271,728,800,87,706,231,470,890,13,479,765,108,9,277,703,43,980,128,525,695,980,220,197,802,215,543,749,158,109,826,786,874,985,220,167,207,462,42,402,728,262,626,988,410,829,959,768,368,190,780,968,348,994,870,793,988,1,811,650,320,525,961,287,123,559,421,263,775,587,893,686,682,672,363,152,584,660,118,233,291,916,632,635,248,758,121,467,973,337,593,975,365,198,146,429,312,733,642,250,206,283,806,232,269,110,439,790,452,68,251,164,298,381,185,309,639,784,824,429,25,948,324,286,217,238,459,749,11,891,110,987,826,170,121,185,302,33,442,75,563,300,364,478,646,911,927,267,709,307,353,550,93,801,4,347,579,65,569,367,809,724,927,74,889,17,827,888,744,941,635,209,564,11,122,168,591,596,47,759,167,990,617,957,964,340,447,674,108,590,357,480,481,277,45,653,644,26,377,680,703,678,31,652,203,647,802,663,595,569,851,889,871,496,815,323,336,704,189,306,133,540,126,402,941,985,59,417,474,403,916,645,693,878,827,614,657,338,471,878,576,109,479,642,103,934,791,149,202,920,636,126,671,915,658,290,309,772,468,912,842,852,504,121,713,543,971,535,746,6,203,663,130,738,636,438,712,950,468,931,171,918,397,586,277,659,2,14,442,400,842,139,723,166,150,401,94,634,276,824,931,420,463,27,117,137,866,883,119,214,732,567,666,915,655,909,648,36,282,501,953,3,24,540,781,3,910,267,542,671,579,136,974,289,651,635,119,40,12,747,37,557,428,679,326,682,88,165,886,369,960,146,377,488,133,233,535,611,823,464,961,605,786,502,476,94,87,106,494,193,917,618,775,416,725,261,277,850,631,712,113,583,228,59,777,91,414,810,173,703,510,865,235,205,546,196,325,769,862,112,813,822,213,261,987,961,443,637,983,292,420,967,64,719,1000,746,172,747,493,585,979,338,765,224,430,157,665,603,134,347,515,45,596,951,951,967,692,279,400,464,959,38,475,452,499,239,11,101,940,161,354,647,278,561,484,67,962,723,235,521,84,291,346,458,896,162,92,190,342,249,771,82,642,417,807,913,4,11,885,390,737,533,897,287,362,247,703,302,660,293,658,402,284,972,414,488,727,282,758,93,176,411,450,595,878,991,412,384,554,565,945,741,833,739,703,484,37,621,636,356,27,478,970,144,957,742,793,402,987,411,72,409,767,884,575,109,685,274,345,521,907,611,923,956,531,39,76,231,750,624,200,781,536,841,48,413,206,534,581,464,85,419,672,237,210,268,502,420,90,483,976,212,20,9,345,432,682,744,450], 607, 818798385),
]

for i, (nums, k, ans) in enumerate(tests):
    res = sol.countPartitions(nums, k)
    if res == ans:
        print(f'Test {i}: PASS')
    else:
        print(f'Test {i}; Fail. Ans: {ans}, Res: {res}')
